from copy import copy
from utils import read_data


def add_direction(loc, d):
    x, y = loc
    if d == 0:
        y += 1
    elif d == 1:
        x += 1
    elif d == 2:
        y -= 1
    elif d == 3:
        x -= 1
    else:
        raise Exception(d)
    return x, y


def get_reverse(d):
    return d + 2 % 4


def explore(loc, direction, crossable, seen, target_keys, steps, path_taken):
    inner_steps = 0
    success_branches = []
    while True:
        # TODO: Need to separate the logic out better.
        # Step one: Pick next move(s). If multiple moves create multiple branches
        # Step two: Make the move
        # Step three: Update dicts etc

        print("")
        print("loc: {}".format(loc))
        print("direction: {}".format(direction))
        print("crossable: {}".format(crossable))
        print("seen: {}".format(seen))
        print("target_keys: {}".format(target_keys))
        print("steps: {}".format(steps))

        # Consider all four options
        possible = [add_direction(loc, d) for d in range(4)]

        # Remove impossible moves
        possible = [i for i in possible if grid_dict[i] != "#"]

        if len(possible) > 1:
            status = {i: seen.get(i) for i in possible} 
            # If multiple unseen, start new searches
            unseen = [k for k, v in status if v is None]
            if len(unseen) > 1:
                # BRANCH
                pass
            if len(unseen) > 0:
                # NEW LOC
                pass
            else:
                # TODO: Reverse
                path_taken[-1]



        seen[loc] = len(crossable)
        # Travel from loc (old position) in direction of d
        new = add_direction(loc, direction)
        print("seen (updated): {}".format(seen))
        print("new: {}".format(new))

        # Do cell
        try:
            value = grid_dict[new]
        except:
            value = "#"
        if value == "#":
            return False, None

        if value in crossable:
            print("Moving from {} to {}".format(loc, new))
            loc = new
        elif value.isalpha():
            if value == value.lower():
                print("Landed on {}".format(value))
                crossable.add(value)
                crossable.add(value.upper())
                # branch
            elif value == value.upper():
                print("Landed on {}".format(value))
                # branch
            else:
                raise Exception("Weird...")
            loc = new
        else:
            # TODO
            raise Exception("Tried to walk into wall")

        prev_value = seen.get(loc)
        if prev_value is not None:
            if prev_value >= len(crossable):
                return False, None

        inner_steps += 1
        steps += 1

        if not target_keys - crossable:
            return True, steps

        # Get possible new directions based on surroundings
        possible = [d for d in set(range(4)) - {get_reverse(direction)} if grid_dict[add_direction(loc, d)] != "#"]

        for new_dir in possible[1:]:
            print("NEW BRANCH: {}".format(loc))
            import pdb
            pdb.set_trace()
            success, steps_taken = explore(
                loc, new_dir, copy(crossable), copy(seen), copy(target_keys), copy(steps)
            )
            if success:
                success_branches.append(steps_taken)

        try:
            new_dir = possible[0]
        except IndexError:
            new_dir = get_reverse(direction)
        direction = new_dir


raw = read_data(18)

raw_1 = '''#########
#b.A.@.a#
#########'''.splitlines()
raw = raw_1

grid = [list(row) for row in raw]
grid_dict = {(x, y): value for (y, row) in enumerate(grid) for (x, value) in enumerate(row)}


start = [
    (x, y) for (x, y), value in grid_dict.items() if value == "@"
]
# print(start)
start = start[0]

# print(grid_dict[start])
# print(grid_dict[add_direction(start, 0)])
# print(grid_dict[add_direction(start, 1)])
# print(grid_dict[add_direction(start, 2)])
# print(grid_dict[add_direction(start, 3)])

print("\n".join("".join(str(i) for i in row) for row in grid))

crossable_ = {".", "@"}
seen_ = {start: len(crossable_)}
target_keys_ = {v for v in grid_dict.values() if v.isalpha() and v.lower() == v}
path_taken_ = [start]

result = explore(start, 1, crossable_, seen_, target_keys_, 0, path_taken_)

import pdb
pdb.set_trace()
